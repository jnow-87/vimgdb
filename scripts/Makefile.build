# XXX target directory is given via $(loc_dir)

	################
	###          ###
	###   init   ###
	###          ###
	################

# remove trailing '/'
loc_dir := $(patsubst %/,%,$(loc_dir))

# init local source and binary tree references, removing trailing '/' (in case $(loc_dir) is empty)
loc_src_tree := $(patsubst %/,%,$(src_tree)/$(loc_dir))
loc_built_tree := $(patsubst %/,%,$(built_tree)/$(loc_dir))

# read subdir-*flags
$(foreach fl,$(supported_flags), \
	$(eval subdir-$(fl) := $(subdir-$(loc_dir)-$(fl))) \
)

# debug message
$(call pdebug,traverse into: src = $(loc_src_tree) - bin = $(loc_built_tree))
$(foreach fl,$(supported_flags), \
	$(call pdebug,    subdir $(fl): $(subdir-$(fl))) \
)
$(call pdebug)


# init local variables
loc_tgt :=
loc_prereq :=
loc_single_obj :=
loc_multi_obj :=
loc_single_lib :=
loc_multi_lib :=
loc_single_bin :=
loc_multi_bin :=


# init variables set by included makefiles
obj-y :=
obj-nobuiltin-y :=
lib-y :=
bin-y :=
subdir-y :=

# init flags, e.g. cflags-y
$(foreach fl,$(supported_flags), \
	$(eval $(fl)-y :=)\
)


	##############################################
	###                                        ###
	###   include Makefile and process input   ###
	###                                        ###
	##############################################

# backup *flags
$(foreach fl,$(supported_flags), \
	$(eval $(fl)_save := $($(fl))) \
)

include $(loc_src_tree)/Makefile

# check if *flags have been altered
$(foreach fl,$(supported_flags), \
	$(if $(strip $(filter-out $($(fl)_save),$($(fl))) $(filter-out $($(fl)),$($(fl)_save))), \
		$(error $(fl) changed modified in $(loc_src_tree)/Makefile from  "$($(fl)_save)" to "$($(fl))"), \
	) \
)

# handle obj-y := <dir>/ syntax
#	add all directories defined in obj-y to subdir-y
#	postfix all directories in obj-y with obj.o, i.e. <dir>/ -> <dir>/obj.o
subdir-y += $(filter %/,$(obj-y) $(obj-nobuiltin-y))
obj-y := $(patsubst %/,%/obj.o,$(obj-y))
obj-nobuiltin-y := $(patsubst %/,%/obj.o,$(obj-nobuiltin-y))


## filter variables set by included Makefile, i.e. obj-y, lib-y, bin-y (cf. $(supported_types)), and identify:

#  single targets - non-compound targets without an associated <target>-y variable
#  multi targets - compound targets with associated <target>-y variable
#
#  collect list of
# 	all targets (single and multi) in $(loc_tgt)
# 	prerequisites in $(loc_prereq)
$(foreach type,$(supported_types), \
	$(eval loc_single_$(type) := $(call filter_single_prereq,$($(type)-y))) \
	$(eval loc_multi_$(type) := $(filter-out $(loc_single_$(type)), $($(type)-y))) \
	\
	$(eval loc_prereq += $(call get_prereq,$(loc_multi_$(type)))) \
	$(eval loc_tgt += $(loc_single_$(type)) $(loc_multi_$(type))) \
	\
	$(call pdebug,    single_$(type): $(loc_single_$(type))) \
	$(call pdebug,    multi_$(type): $(loc_multi_$(type))) \
)

#  add single and multi targets to the global lists (i.e. $(obj), $(lib), $(bin), appending
#  the appropriate binary tree
$(foreach type,$(supported_types), \
	$(eval $(type) += $(addprefix $(loc_built_tree)/,$(loc_single_$(type)) $(loc_multi_$(type)))) \
)

#  handle multi targets that specify a directory as prerequisite, i.e. <target>-y := <dir>/
#  	filter directories to $(dirs)
#  		select appropriate prefix by checking if the directory exists within $(loc_src_tree),
#  		if not assume it exists in $(src_tree)
dir-y :=

$(foreach type,$(supported_types), \
	$(foreach o,$(loc_multi_$(type)), \
		$(eval dirs :=) \
		$(foreach d,$(filter %/,$($(o)-y)), \
			$(if $(call exists,$(loc_src_tree)/$(d)), \
				$(eval subdir-y += $(d)) \
				$(eval dirs += $(loc_built_tree)/$(d)obj.o) \
				, \
				$(eval dir-y += $(d)) \
				$(eval dirs += $(built_tree)/$(d)obj.o) \
			) \
		) \
		$(eval $(o)-y := $(filter-out %/,$($(o)-y)) $(dirs)) \
	) \
)

$(call pdebug)

# remove duplicates
loc_tgt := $(sort $(loc_tgt))
loc_prereq := $(sort $(loc_prereq))
dir-y := $(sort $(dir-y))

$(call pdebug,    loc_tgt: $(loc_tgt))
$(call pdebug,    loc_prereq: $(loc_prereq))
$(call pdebug)


	###########################
	###                     ###
	###   rule generation   ###
	###                     ###
	###########################

## flags

# target specific flag rules, i.e. <target>-*flags
# 	this applies to all files (direct targets and prerequisites)
$(foreach f,$(loc_tgt) $(loc_prereq), \
	$(foreach fl,$(supported_flags), \
		$(call gen_rule_tgt_flags,$(f),$(fl),$(loc_built_tree)/) \
	) \
)

# local flags, i.e. *flags-y
$(foreach f,$(loc_tgt) $(loc_prereq), \
	$(foreach fl,$(supported_flags), \
		$(call gen_rule_loc_flags,$(f),$(fl),$(loc_built_tree)/) \
	) \
)

# local flags for ./obj.o
$(if $(obj-y), \
	$(foreach fl,$(supported_flags), \
		$(call gen_rule_loc_flags,obj.o,$(fl),$(loc_built_tree)/) \
	) \
)


## build

# compound target rules
$(call gen_rule_multi,cmd_cc_o_o,$(loc_multi_obj),$(loc_built_tree)/)
$(call gen_rule_multi,cmd_cc_o_o,$(loc_multi_obj-nobuiltin),$(loc_built_tree)/)
$(call gen_rule_multi,cmd_cc_lib_o,$(loc_multi_lib),$(loc_built_tree)/)
$(call gen_rule_multi,cmd_cc_bin_o,$(loc_multi_bin),$(loc_built_tree)/)

# pattern rules for all non-compound targets (obj and lib) and prerequisites
$(if $(strip $(loc_single_obj) $(loc_single_lib) $(loc_single_bin) $(loc_prereq)), \
	$(call gen_rule_basic,cmd_cc_i,$(loc_built_tree)/%.S.i,$(loc_src_tree)/%.S) \
	$(call gen_rule_basic,cmd_cc_i,$(loc_built_tree)/%.i,$(loc_src_tree)/%.S) \
	$(call gen_rule_basic,cmd_cc_i,$(loc_built_tree)/%.i,$(loc_src_tree)/%.c) \
	$(call gen_rule_basic,cmd_cc_o_s,$(loc_built_tree)/%.o,$(loc_built_tree)/%.S.i) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.o,$(loc_src_tree)/%.c) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.o,$(loc_src_tree)/%.cc) \
	$(call gen_rule_basic,cmd_cc_c_y,$(loc_built_tree)/%.tab.cc,$(loc_src_tree)/%.y) \
	$(call gen_rule_basic, ,$(loc_built_tree)/%.tab.h,$(loc_built_tree)/%.tab.cc) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.tab.o,$(loc_built_tree)/%.tab.cc) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.o,$(loc_built_tree)/%.tab.cc) \
	$(call gen_rule_basic,cmd_cc_c_l,$(loc_built_tree)/%.lex.cc,$(loc_src_tree)/%.l) \
	$(call gen_rule_basic, ,$(loc_built_tree)/%.lex.h,$(loc_built_tree)/%.lex.cc) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.lex.o,$(loc_built_tree)/%.lex.cc) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.o,$(loc_built_tree)/%.lex.cc) \
	$(call gen_rule_basic,cmd_cc_cxx_gperf,$(loc_built_tree)/%.hash.cc,$(loc_src_tree)/%.gperf) \
	$(call gen_rule_basic, ,$(loc_built_tree)/%.hash.h,$(loc_built_tree)/%.hash.cc) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.hash.o,$(loc_built_tree)/%.hash.cc) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.o,$(loc_built_tree)/%.hash.cc) \
	$(call gen_rule_basic,cmd_cc_lib_o,$(loc_built_tree)/%.a,$(loc_built_tree)/%.o) \
	, \
)

# rule to build $(loc_built_tree)/obj.o if obj-y is not empty
$(if $(obj-y), \
	$(call gen_rule_basic,cmd_cc_o_o,$(loc_built_tree)/obj.o,$(addprefix $(loc_built_tree)/,$(obj-y))) \
	, \
)

# special handling of bin targets,
# 	since the correponding pattern rules (<dir>/%: %) do not work
$(foreach f,$(loc_single_bin), \
	$(call gen_rule_basic,cmd_cc_bin_o,$(loc_built_tree)/$(f),$(loc_built_tree)/$(f).o) \
)

	
	##################################
	###                            ###
	###   subdirectory traversal   ###
	###                            ###
	##################################

# handle subdir-*flags
# 	assign <subdir>-*flags to subdir-<subdir>-*flags to avoid overwriting them by name collisions
$(foreach d,$(patsubst %/,%,$(subdir-y)), \
	$(foreach fl,$(supported_flags), \
		$(eval subdir-$(loc_dir)/$(d)-$(fl) := $($(d)-$(fl)) $(subdir-$(fl))) \
		$(eval $(d)-$(fl) :=) \
	) \
)

# include sub-directories to $(loc_src_tree) listed in $(subdir-y) and
# sub-directories to $(src_tree) listed in $(dir-y)
$(call pdebug)
$(call pdebug,    subdir: $(subdir-y))
$(call pdebug,    dir: $(dir-y))
$(call pdebug)

$(call dinclude,$(addprefix $(loc_dir)/,$(subdir-y)) $(dir-y))
