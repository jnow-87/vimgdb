# XXX target directory is given via $(loc_dir)

	################
	###          ###
	###   init   ###
	###          ###
	################

# remove trailing '/'
loc_dir := $(patsubst %/,%,$(loc_dir))

# init local source and binary tree references, removing trailing '/' (in case $(loc_dir) is empty)
loc_src_tree := $(patsubst %/,%,$(src_tree)/$(loc_dir))
loc_built_tree := $(patsubst %/,%,$(built_tree)/$(loc_dir))

# read subdir-*flags
$(foreach fl,$(supported_flags), \
	$(eval subdir-$(fl) := $(subdir-$(loc_dir)-$(fl))) \
)

# debug message
$(call pdebug,traverse into: src = $(loc_src_tree) - bin = $(loc_built_tree))
$(foreach fl,$(supported_flags), \
	$(call pdebug,    subdir $(fl): $(subdir-$(fl))) \
)
$(call pdebug)


# init local variables
loc_tgt :=
loc_prereq :=
loc_single_obj :=
loc_multi_obj :=
loc_single_lib :=
loc_multi_lib :=
loc_single_bin :=
loc_multi_bin :=


# init variables set by included makefiles
obj-y :=
lib-y :=
bin-y :=
subdir-y :=
hostobj-y :=
hostlib-y :=
hostbin-y :=

# init flags, e.g. cflags-y
$(foreach fl,$(supported_flags), \
	$(eval $(fl)-y :=)\
)


	##############################################
	###                                        ###
	###   include Makefile and process input   ###
	###                                        ###
	##############################################

# backup *flags
$(foreach fl,$(supported_flags), \
	$(eval $(fl)_save := $($(fl))) \
)

include $(loc_src_tree)/Makefile

# check if *flags have been altered
$(foreach fl,$(supported_flags), \
	$(if $(strip $(filter-out $($(fl)_save),$($(fl))) $(filter-out $($(fl)),$($(fl)_save))), \
		$(error $(fl) changed modified in $(loc_src_tree)/Makefile from  "$($(fl)_save)" to "$($(fl))"), \
	) \
)

# check that either normal (obj-y) or host (hostobj-y) targets have been defined
# if host targets are defined map them to the variables for normal targets and set host := "host"
$(if $(hostobj-y)$(hostlib-y)$(hostbin-y), \
	$(if $(obj-y)$(lib-y)$(bin-y), \
		$(error host- and target-architecture targets defined within the same Makefile "$(loc_src_tree)/Makefile"), \
		$(eval host := host) \
		$(eval obj-y := $(hostobj-y)) \
		$(eval lib-y := $(hostlib-y)) \
		$(eval bin-y := $(hostbin-y)) \
	),\
	$(eval host :=) \
)

# handle obj-y := <dir>/ syntax
#	add all directories defined in obj-y to subdir-y
#	postfix all directories in obj-y with obj.o, i.e. <dir>/ -> <dir>/obj.o
subdir-y += $(filter %/,$(obj-y))
obj-y := $(patsubst %/,%/obj.o,$(obj-y))

# filter variables set by included Makefile, i.e. obj-y, lib-y, bin-y (cf. $(supported_types)), and identify:
# 	single targets - non-compound targets without an associated <target>-y variable
# 	multi targets - compound targets with associated <target>-y variable
#
# 	collect list of
# 		all targets (single and multi) in $(loc_tgt)
# 		prerequisites in $(loc_prereq)
#
# 	add single and multi targets to the global lists (i.e. $(obj), $(lib), $(bin), appending
# 		the appropriate binary tree
#
# 	handle multi targets that specify a directory as prerequisite, i.e. <target>-y := <dir>/
$(foreach type,$(supported_types), \
	$(eval loc_single_$(type) := $(call filter_single_prereq,$($(type)-y))) \
	$(eval loc_multi_$(type) := $(filter-out $(loc_single_$(type)), $($(type)-y))) \
	\
	$(eval loc_prereq += $(call get_prereq,$(loc_multi_$(type)))) \
	$(eval loc_tgt += $(loc_single_$(type)) $(loc_multi_$(type))) \
	\
	$(call pdebug,    single_$(type): $(loc_single_$(type))) \
	$(call pdebug,    multi_$(type): $(loc_multi_$(type))) \
	\
	$(eval $(type) += $(addprefix $(loc_built_tree)/,$(loc_single_$(type)) $(loc_multi_$(type)))) \
	\
	$(foreach o,$(loc_multi_$(type)),\
		$(eval subdir-y += $(filter %/,$($(o)-y))) \
		$(eval $(o)-y := $(patsubst %/,$(loc_built_tree)/%/obj.o,$($(o)-y))) \
	) \
)

$(call pdebug)

# remove duplicates
loc_tgt := $(sort $(loc_tgt))
loc_prereq := $(sort $(loc_prereq))


	###########################
	###                     ###
	###   rule generation   ###
	###                     ###
	###########################

## flags

# target specific flag rules, i.e. <target>-*flags
# 	this applies to all files (direct targets and prerequisites)
$(foreach f,$(loc_tgt) $(loc_prereq), \
	$(foreach fl,$(supported_flags), \
		$(call gen_rule_tgt_flags,$(f),$(fl),$(loc_built_tree)/) \
	) \
)

# local flags, i.e. *flags-y
# 	this only applies to direct targets only, since their prerequisites inherit the flags anyway
$(foreach f,$(loc_tgt), \
	$(foreach fl,$(supported_flags), \
		$(call gen_rule_loc_flags,$(f),$(fl),$(loc_built_tree)/) \
	) \
)


## build

# compound target rules
$(call gen_rule_multi,cmd_cc_o_o,$(loc_multi_obj),$(loc_built_tree)/)
$(call gen_rule_multi,cmd_cc_lib_o,$(loc_multi_lib),$(loc_built_tree)/)
$(call gen_rule_multi,cmd_cc_bin_o,$(loc_multi_bin),$(loc_built_tree)/)

# pattern rules for all non-compound targets (obj and lib) and prerequisites
$(if $(strip $(loc_single_obj) $(loc_single_lib) $(loc_single_bin) $(loc_prereq)), \
	$(call gen_rule_basic,cmd_cc_i,$(loc_built_tree)/%.S.i,$(loc_src_tree)/%.S) \
	$(call gen_rule_basic,cmd_cc_i,$(loc_built_tree)/%.i,$(loc_src_tree)/%.S) \
	$(call gen_rule_basic,cmd_cc_i,$(loc_built_tree)/%.i,$(loc_src_tree)/%.c) \
	$(call gen_rule_basic,cmd_cc_o_s,$(loc_built_tree)/%.o,$(loc_built_tree)/%.S.i) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.o,$(loc_src_tree)/%.c) \
	$(call gen_rule_basic,cmd_cc_o_cxx,$(loc_built_tree)/%.o,$(loc_src_tree)/%.cc) \
	$(call gen_rule_basic,cmd_cc_c_y,$(loc_built_tree)/%.tab.c,$(loc_src_tree)/%.y) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.tab.o,$(loc_built_tree)/%.tab.c) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.o,$(loc_built_tree)/%.tab.c) \
	$(call gen_rule_basic,cmd_cc_c_l,$(loc_built_tree)/%.lex.c,$(loc_src_tree)/%.l) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.lex.o,$(loc_built_tree)/%.lex.c) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.o,$(loc_built_tree)/%.lex.c) \
	$(call gen_rule_basic,cmd_cc_c_h,$(loc_built_tree)/%.hash.c,$(loc_src_tree)/%.gperf) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.hash.o,$(loc_built_tree)/%.hash.c) \
	$(call gen_rule_basic,cmd_cc_o_c,$(loc_built_tree)/%.o,$(loc_built_tree)/%.hash.c) \
	$(call gen_rule_basic,cmd_cc_lib_o,$(loc_built_tree)/%.a,$(loc_built_tree)/%.o) \
	, \
)

# rule to build $(loc_built_tree)/obj.o if obj-y is not empty
$(if $(obj-y), \
	$(call gen_rule_basic,cmd_cc_o_o,$(loc_built_tree)/obj.o,$(addprefix $(loc_built_tree)/,$(obj-y))) \
	, \
)

# special handling of bin targets,
# 	since the correponding pattern rules (<dir>/%: %) do not work
$(foreach f,$(loc_single_bin), \
	$(call gen_rule_basic,cmd_cc_bin_o,$(loc_built_tree)/$(f),$(loc_built_tree)/$(f).o) \
)

	
	##################################
	###                            ###
	###   subdirectory traversal   ###
	###                            ###
	##################################

# handle subdir-*flags
# 	assign <subdir>-*flags to subdir-<subdir>-*flags to avoid overwriting them by name collisions
$(foreach d,$(patsubst %/,%,$(subdir-y)), \
	$(foreach fl,$(supported_flags), \
		$(eval subdir-$(loc_dir)/$(d)-$(fl) := $($(d)-$(fl)) $(subdir-$(fl))) \
		$(eval $(d)-$(fl) :=) \
	) \
)

# include sub-directories listed in $(subdir-y)
$(call pdebug)
$(call pdebug,    subdir: $(subdir-y))
$(call pdebug)

$(call dinclude,$(addprefix $(loc_dir)/,$(subdir-y)))
